#### 1. 复杂度

>程序执行时需要的计算量和内存空间（和代码是否简介无关）。
>
>复杂度是**数量级**（方便记忆，推广），不是具体的数字。
>
>一般针对一个具体的算法，而非一个完整的系统。
>
>![img](https://cdn.nlark.com/yuque/0/2022/png/23159656/1652193475710-0939b464-0bbe-4015-9b4e-5be847a668d5.png)

##### 时间复杂度

**程序执行时所需要的计算量（CPU）**

>1. O(1)   一次就够（数量级）
>
>   ```javascript
>   let arr = [1,2,3]
>   
>   function addition(arr){
>     	return arr[0] + arr[1] + arr[3]
>   }
>   ```
>
>2. O(n)  和传输的数量一样（数量级）
>
>   ```javascript
>   let arr = [1,2,3]
>   
>   function addition(arr){
>     	for(const item of arr){
>         console.log(item)
>       }
>   }
>   ```
>
>3. O(n^2)  数据量的平方（数量级）
>
>   ```javascript
>   let arr = [1,2,3]
>   
>   function addition(arr){
>     	for(const item of arr){
>         	for(const item of arr){
>        		 console.log(item)
>       		}
>       }
>   }
>   ```
>
>4. O(logn) 数据量的对数（数量级）
>
>   例：二分查找法
>
>5. O(n*logn) 数据量乘以数据量的对数（数量级）
>
>   ```javascript
>   let arr = [1,2,3]
>   
>   function addition(arr){
>     	for(const item of arr){
>         // 二分查找
>       }
>   }
>   ```

##### 空间复杂度

**程序执行时所需要的内存空间** 

>1. O(1)
>
>   ```javascript
>   let arr = []
>   
>   function addition(arr){
>     	arr[0] = 1
>     	arr[1] = 2
>   }
>   ```
>
>2. O(n)
>
>   ```javascript
>   let arr = [1,2,3,4,5]
>   
>   function addition(arr){
>      let temp = []
>      for(const item if arr){
>         temp.push(item)
>      }
>     return arr
>   }
>   ```
>
>算法到O(n^2) 算法基本是不可用的 ！
>
>要控制到O(n) 以内
>
>普通 vdom tree diff 算法 O(n^3)   react 优化后 O(n)
>
>前端开发：重时间，轻空间

##### 将一个数组旋转K步

> + 输入一个数组 [ 1 , 2 , 3 , 4 , 5 , 6, 7 ]
> + k = 3，即旋转 3 步
> + 输出 [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ]
>
> ##### 思路
>
> 1. 把末尾的元素挨个pop，然后unshift到数组前面
> 2. 把数组拆分，最后concat拼接到一起
>
> ```typescript
> // 思路一 把末尾的元素挨个pop，然后unshift到数组前面
> function reverse(arr:[],k:number):number[]{
>   	const length = arr.length
>     if(length === 0 || !k) return arr
>   	const step = Math.abs(k % length)  // abs 取绝对值
>     // k 不是数字 step 就是 NaN  i < step 返回 false   
>     // 至少是O(n)级别的   
>     for(let i = 0; i< step; i++){
> 			const n = arr.pop()
>       if(n !== null){
>         arr.unshift(n)
>       }
>     }  
>   return arr
> }
> 
> 
> // 思路二 把数组拆分，最后concat拼接到一起
> function reverse(arr:[],k:number):number[]{
>   	const length = arr.length
>     if(length === 0 || !k) return arr
>   	const step = Math.abs(k % length)  // abs 取绝对值
>     	
>    	const part1 = arr.slice(-step)
>     const part2 = arr.slice(0,length - step)
>     const part3 = part1.concat(part2)
>   return part3
> }
> 
> // 测试用例 jest 引用 方法
> describe('数组旋转',()=>{
>   it('正常情况',()=>{
>     const arr = [1,2,3,4,5,6,7]
>     const k = 3
>     const res = reverse(arr,k)
>     expect(res).toEqual([5,6,7,1,2,3,4])
>   })
>   
>   it('数组为空',()=>{
>     const res = reverse([],3)
>     expect(res).toEqual([])
>   })
>   
>   it('k为负数',()=>{
>     const arr = [1,2,3,4,5,6,7]
>     const k = -3
>     const res = reverse(arr,k)
>     expect(res).toEqual([5,6,7,1,2,3,4])
>   })
>   
>   it('k不是数字',()=>{
>     const arr = [1,2,3,4,5,6,7]
>     const k = ''
>     const res = reverse(arr,k)
>     expect(res).toEqual([1,2,3,4,5,6,7])
>   })
> })
> 
> ```
>
> #### 总结
>
> 思路1： 时间复杂度O(n^2)  空间复杂度O(1)
>
> 分析：**数组是一个有序的数据结构   unshift（时间复杂度：O(n)）、shift、splice 非常费时**
>
> 思路2：时间复杂度O(1)       空间复杂度O(n)
>
> 分析：**slice不会动原数组（时间复杂度：（O(1)））**
>
>  
>
> 不要过度优化 代码逻辑清晰 易读

#### 2. 栈数据结构

>#### 栈的概念
>
>- 先进后出
>- API：push pop length
>- 相关的：队列、堆
>
><img src="https://cdn.nlark.com/yuque/0/2022/png/23159656/1652362055025-596fb305-09e5-47a9-ab6b-e32a9cdd42f9.png" alt="img" style="zoom: 33%;" />
>
>#### 栈 vs 数组
>
>- 栈，逻辑结构。理论模型，不管如何实现，不受任何语言的限制。
>- 数组，物理结构。真正的功能实现，受限于编程语言。

##### 判断字符串是否括号匹配

>- 一个字符串 s 可能包含 {} [] () 三种括号
>- 判断 s 是否是括号匹配的
>- 如 (a{b}c) 匹配，而{a(b 或 {a(b}c) 就不匹配
>
>#### 思路
>
>* 遇到 ({[ 就压栈
>* 遇到右括号 ]}) 判断栈顶，匹配就出栈
>* 最后判断栈的 length 是否为0  
>
>```typescript
>function isMatch(top: string, k: string): boolean {
> if (top === "(" && k === ")") return true;
> else if (top === "{" && k === "}") return true;
> else if (top === "[" && k === "]") return true;
> else return false;
>}
>
>export function mathBracket(s: string): boolean {
> const length = s.length;
> if (length == 0) return true;
> const left = "({[";
> const right = ")}]";
> const stack = [];
> for (let i = 0; i < length; i++) {
>   const k = s[i];
>   if (left.includes(k)) {
>     stack.push(k);
>   } else if (right.includes(k)) {
>     const top = stack[stack.length - 1];
>     if (isMatch(top, k)) {
>       stack.pop();
>     } else {
>       return false;
>     }
>   }
> }
>
> return stack.length === 0;
>}
>```
>
>单元测试
>
>```javascript
>
>describe("括号匹配测试", () => {
> it("正常情况", () => {
>   const s = "(a{b[c]d}e)";
>   const res = mathBracket(s);
>   expect(res).toBe(true);
> });
>
> it("不匹配情况", () => {
>   const s = "(a{b[c]d}e]";
>   const res = mathBracket(s);
>   expect(res).toBe(false);
> });
>
> it("顺序不对情况", () => {
>   const s = "(a{b[cd}e)]";
>   const res = mathBracket(s);
>   expect(res).toBe(false);
> });
>});
>
>```
>
>#### 总结
>
>时间复杂度 **O(n)** 
>
>空间复杂度 **O(n)**
>
>

#### 3. 队列数据结构

>#### 队列的概念
>
>- 先进先出
>- API：add delete length
>
>#### 队列 vs 数组
>
>- 队列逻辑结构，数据模型。
>- 简单的可以用数组、链表实现。
>- 复杂的需要单独设计。

##### 两个栈实现一个队列

>#### 思路
>
>- unshift 时间复杂度O(n) 浪费性能
>- 用两个栈stack1、stack2实现
>- 入栈压入stack1，出栈将stack1全部pop、push给stack2
>- 出栈stack2 pop，把剩下的都pop、push给stack2
>
>```javascript
>export class Myqueue {
>  private stack1: number[] = [];
>  private stack2: number[] = [];
>
>  add(n: number) {
>    this.stack1.push(n);
>  }
>
>  delete(): number | null {
>    while (this.stack1.length) {
>      const n = this.stack1.pop();
>      if (n) this.stack2.push(n);
>    }
>    const res = this.stack2.pop() || null;
>
>    while (this.stack2.length) {
>      const n = this.stack2.pop();
>      if (n) this.stack1.push(n);
>    }
>    return res;
>  }
>
>  get length() {
>    return this.stack1.length;
>  }
>}
>```
>
>单元测试
>
>```javascript
>
>describe("队列测试", () => {
>  it("正常情况", () => {
>    const q = new Myqueue();
>    expect(q.length).toBe(0);
>
>    q.add(100);
>    q.add(200);
>    q.add(300);
>
>    expect(q.length).toBe(3);
>  });
>
>  it("delete", () => {
>    const q = new Myqueue();
>    q.add(100);
>    const res = q.delete();
>    expect(res).toBe(100);
>  });
>
>  it("delete", () => {
>    const q = new Myqueue();
>    const res = q.delete();
>    expect(res).toBe(null);
>  });
>});
>
>```
>
>

#### 4. 链表数据结构 

> #### 链表的概念
>
> * 链表是一个物理结构，类似于数组。
> * 数组需要一段连续的内存空间，而链表是零散的。
> * 链表的数据结构：**{value,next?,prev?}**
>
> #### 链表 vs 数组
>
> * 都是有序结构
> * 链表查询慢**O(n)** 增删快 **O(1)**
> * 数组查询快**O(n)** 增删慢 **O(n)**
>
> #### 使用js创建一个链表
>
> ```typescript
> 
> interface listNode {
>   value: number;
>   next?: listNode;
> }
>   
> export function createLinks(arr: number[]): listNode {
>   const length = arr.length;
>   if (!length) throw new Error("arr length is must be > 0");
> 
>   // 最后一个节点
>   let curNode: listNode = {
>     value: arr[length - 1],
>   };
> 
>   if (length === 1) return curNode;
> 
>   for (let i = length - 2; i >= 0; i--) {
>     curNode = {
>       value: arr[i],
>       next: curNode,
>     };
>   }
> 
>   return curNode;
> }
> 
> ```
>
> 



##### 定义一个js函数，反转一个链表

>#### 解题思路
>
>* 反转，即节点的next指向前一个节点
>* 问题：很容易造成nextNode丢失
>* 需要三个指针，curNode、prevNode、nextNode
>
>```typescript
>export function reverseListNode(listNode: listNode): listNode {
>  // 创建三个指针
>  let currentNode: listNode | undefined = undefined;
>  let previewNode: listNode | undefined = undefined;
>  let nextNode: listNode | undefined = listNode;
>  while (nextNode) {
>    // 删除第一个节点的next 防止死循环
>    if (currentNode && !previewNode) {
>      delete currentNode.next;
>    }
>    // 反转节点
>    if (currentNode && previewNode) {
>      currentNode.next = previewNode;
>    }
>
>    // 将三个指针向后瞬移
>    previewNode = currentNode;
>    currentNode = nextNode;
>    nextNode = nextNode.next;
>  }
>
>  // 处理 最后一个没有next的节点
>  currentNode!.next = previewNode;
>  return currentNode!;
>}
>
>```
>
>

##### 用链表实现一个队列

>* 单向列表，但要同时记录**head**和**tail**
>* **tail**入队，**head**出队
>* **length**要实时获取，不能遍历获取。
