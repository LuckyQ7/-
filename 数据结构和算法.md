#### 1. 复杂度

>程序执行时需要的计算量和内存空间（和代码是否简介无关）。
>
>复杂度是**数量级**（方便记忆，推广），不是具体的数字。
>
>一般针对一个具体的算法，而非一个完整的系统。
>
>![img](https://cdn.nlark.com/yuque/0/2022/png/23159656/1652193475710-0939b464-0bbe-4015-9b4e-5be847a668d5.png)

##### 时间复杂度

**程序执行时所需要的计算量（CPU）**

>1. O(1)   一次就够（数量级）
>
>   ```javascript
>   let arr = [1,2,3]
>   
>   function addition(arr){
>     	return arr[0] + arr[1] + arr[3]
>   }
>   ```
>
>2. O(n)  和传输的数量一样（数量级）
>
>   ```javascript
>   let arr = [1,2,3]
>   
>   function addition(arr){
>     	for(const item of arr){
>         console.log(item)
>       }
>   }
>   ```
>
>3. O(n^2)  数据量的平方（数量级）
>
>   ```javascript
>   let arr = [1,2,3]
>   
>   function addition(arr){
>     	for(const item of arr){
>         	for(const item of arr){
>        		 console.log(item)
>       		}
>       }
>   }
>   ```
>
>4. O(logn) 数据量的对数（数量级）
>
>   例：二分查找法
>
>5. O(n*logn) 数据量乘以数据量的对数（数量级）
>
>   ```javascript
>   let arr = [1,2,3]
>   
>   function addition(arr){
>     	for(const item of arr){
>         // 二分查找
>       }
>   }
>   ```

##### 空间复杂度

**程序执行时所需要的内存空间** 

>1. O(1)
>
>   ```javascript
>   let arr = []
>   
>   function addition(arr){
>     	arr[0] = 1
>     	arr[1] = 2
>   }
>   ```
>
>2. O(n)
>
>   ```javascript
>   let arr = [1,2,3,4,5]
>   
>   function addition(arr){
>      let temp = []
>      for(const item if arr){
>         temp.push(item)
>      }
>     return arr
>   }
>   ```
>
>算法到O(n^2) 算法基本是不可用的 ！
>
>要控制到O(n) 以内
>
>普通 vdom tree diff 算法 O(n^3)   react 优化后 O(n)
>
>前端开发：重时间，轻空间

##### 将一个数组旋转K步

> + 输入一个数组 [ 1 , 2 , 3 , 4 , 5 , 6, 7 ]
> + k = 3，即旋转 3 步
> + 输出 [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ]
>
> ##### 思路
>
> 1. 把末尾的元素挨个pop，然后unshift到数组前面
> 2. 把数组拆分，最后concat拼接到一起
>
> ```typescript
> // 思路一 把末尾的元素挨个pop，然后unshift到数组前面
> function reverse(arr:[],k:number):number[]{
>   	const length = arr.length
>     if(length === 0 || !k) return arr
>   	const step = Math.abs(k % length)  // abs 取绝对值
>     // k 不是数字 step 就是 NaN  i < step 返回 false   
>     // 至少是O(n)级别的   
>     for(let i = 0; i< step; i++){
> 			const n = arr.pop()
>       if(n !== null){
>         arr.unshift(n)
>       }
>     }  
>   return arr
> }
> 
> 
> // 思路二 把数组拆分，最后concat拼接到一起
> function reverse(arr:[],k:number):number[]{
>   	const length = arr.length
>     if(length === 0 || !k) return arr
>   	const step = Math.abs(k % length)  // abs 取绝对值
>     	
>    	const part1 = arr.slice(-step)
>     const part2 = arr.slice(0,length - step)
>     const part3 = part1.concat(part2)
>   return part3
> }
> 
> // 测试用例 jest 引用 方法
> describe('数组旋转',()=>{
>   it('正常情况',()=>{
>     const arr = [1,2,3,4,5,6,7]
>     const k = 3
>     const res = reverse(arr,k)
>     expect(res).toEqual([5,6,7,1,2,3,4])
>   })
>   
>   it('数组为空',()=>{
>     const res = reverse([],3)
>     expect(res).toEqual([])
>   })
>   
>   it('k为负数',()=>{
>     const arr = [1,2,3,4,5,6,7]
>     const k = -3
>     const res = reverse(arr,k)
>     expect(res).toEqual([5,6,7,1,2,3,4])
>   })
>   
>   it('k不是数字',()=>{
>     const arr = [1,2,3,4,5,6,7]
>     const k = ''
>     const res = reverse(arr,k)
>     expect(res).toEqual([1,2,3,4,5,6,7])
>   })
> })
> 
> ```
>
> #### 总结
>
> 思路1： 时间复杂度O(n^2)  空间复杂度O(1)
>
> 分析：**数组是一个有序的数据结构   unshift（时间复杂度：O(n)）、shift、splice 非常费时**
>
> 思路2：时间复杂度O(1)       空间复杂度O(n)
>
> 分析：**slice不会动原数组（时间复杂度：（O(1)））**
>
>  
>
> 不要过度优化 代码逻辑清晰 易读

#### 2. 栈数据结构

>#### 栈的概念
>
>- 先进后出
>- API：push pop length
>- 相关的：队列、堆
>
><img src="https://cdn.nlark.com/yuque/0/2022/png/23159656/1652362055025-596fb305-09e5-47a9-ab6b-e32a9cdd42f9.png" alt="img" style="zoom: 33%;" />
>
>
>
>#### 栈 vs 数组
>
>- 栈，逻辑结构。理论模型，不管如何实现，不受任何语言的限制。
>- 数组，物理结构。真正的功能实现，受限于编程语言。
>
>

##### 判断字符串是否括号匹配

>- 一个字符串 s 可能包含 {} [] () 三种括号
>- 判断 s 是否是括号匹配的
>- 如 (a{b}c) 匹配，而{a(b 或 {a(b}c) 就不匹配
>
>#### 思路
>
>* 遇到 ({[ 就压栈
>* 遇到右括号 ]}) 判断栈顶，匹配就出栈
>* 最后判断栈的 length 是否为0  
>
>```typescript
>function isMatch(top: string, k: string): boolean {
> if (top === "(" && k === ")") return true;
> else if (top === "{" && k === "}") return true;
> else if (top === "[" && k === "]") return true;
> else return false;
>}
>
>export function mathBracket(s: string): boolean {
> const length = s.length;
> if (length == 0) return true;
> const left = "({[";
> const right = ")}]";
> const stack = [];
> for (let i = 0; i < length; i++) {
>   const k = s[i];
>   if (left.includes(k)) {
>     stack.push(k);
>   } else if (right.includes(k)) {
>     const top = stack[stack.length - 1];
>     if (isMatch(top, k)) {
>       stack.pop();
>     } else {
>       return false;
>     }
>   }
> }
>
> return stack.length === 0;
>}
>```
>
>单元测试
>
>```javascript
>
>describe("括号匹配测试", () => {
> it("正常情况", () => {
>   const s = "(a{b[c]d}e)";
>   const res = mathBracket(s);
>   expect(res).toBe(true);
> });
>
> it("不匹配情况", () => {
>   const s = "(a{b[c]d}e]";
>   const res = mathBracket(s);
>   expect(res).toBe(false);
> });
>
> it("顺序不对情况", () => {
>   const s = "(a{b[cd}e)]";
>   const res = mathBracket(s);
>   expect(res).toBe(false);
> });
>});
>
>```
>
>#### 总结
>
>时间复杂度 **O(n)** 
>
>空间复杂度 **O(n)**
>
>

#### 3. 队列数据结构



>#### 队列的概念
>
>- 先进先出
>- API：add delete length
>
>#### 队列 vs 数组
>
>- 队列逻辑结构，数据模型。
>- 简单的可以用数组、链表实现。
>- 复杂的需要单独设计。
>
>![队列](/Volumes/文件/网课资料/fe-interview-100-wiki/数据结构和算法/img/队列.png)

##### 两个栈实现一个队列

>#### 思路
>
>- unshift 时间复杂度O(n) 浪费性能
>- 用两个栈stack1、stack2实现
>- 入栈压入stack1，出栈将stack1全部pop、push给stack2
>- 出栈stack2 pop，把剩下的都pop、push给stack2
>
>```javascript
>export class Myqueue {
>  private stack1: number[] = [];
>  private stack2: number[] = [];
>
>  add(n: number) {
>    this.stack1.push(n);
>  }
>
>  delete(): number | null {
>    while (this.stack1.length) {
>      const n = this.stack1.pop();
>      if (n) this.stack2.push(n);
>    }
>    const res = this.stack2.pop() || null;
>
>    while (this.stack2.length) {
>      const n = this.stack2.pop();
>      if (n) this.stack1.push(n);
>    }
>    return res;
>  }
>
>  get length() {
>    return this.stack1.length;
>  }
>}
>```
>
>单元测试
>
>```javascript
>
>describe("队列测试", () => {
>  it("正常情况", () => {
>    const q = new Myqueue();
>    expect(q.length).toBe(0);
>
>    q.add(100);
>    q.add(200);
>    q.add(300);
>
>    expect(q.length).toBe(3);
>  });
>
>  it("delete", () => {
>    const q = new Myqueue();
>    q.add(100);
>    const res = q.delete();
>    expect(res).toBe(100);
>  });
>
>  it("delete", () => {
>    const q = new Myqueue();
>    const res = q.delete();
>    expect(res).toBe(null);
>  });
>});
>
>```
>
>

#### 4. 链表数据结构 

> #### 链表的概念
>
> * 链表是一个物理结构，类似于数组。
> * 数组需要一段连续的内存空间，而链表是零散的。
> * 链表的数据结构：**{value,next?,prev?}**
>
> #### 链表 vs 数组
>
> * 都是有序结构
> * 链表查询慢**O(n)** 增删快 **O(1)**
> * 数组查询快**O(n)** 增删慢 **O(n)**
>
> ![链表](/Volumes/文件/网课资料/fe-interview-100-wiki/数据结构和算法/img/链表.png)
>
> #### 使用js创建一个链表
>
> ```typescript
> 
> interface listNode {
>   value: number;
>   next?: listNode;
> }
> 
> export function createLinks(arr: number[]): listNode {
>   const length = arr.length;
>   if (!length) throw new Error("arr length is must be > 0");
> 
>   // 最后一个节点
>   let curNode: listNode = {
>     value: arr[length - 1],
>   };
> 
>   if (length === 1) return curNode;
> 
>   for (let i = length - 2; i >= 0; i--) {
>     curNode = {
>       value: arr[i],
>       next: curNode,
>     };
>   }
> 
>   return curNode;
> }
> 
> ```
>
> 



##### 定义一个js函数，反转一个链表

>#### 解题思路
>
>* 反转，即节点的next指向前一个节点
>* 问题：很容易造成nextNode丢失
>* 需要三个指针，curNode、prevNode、nextNode
>
>```typescript
>export function reverseListNode(listNode: listNode): listNode {
>  // 创建三个指针
>  let currentNode: listNode | undefined = undefined;
>  let previewNode: listNode | undefined = undefined;
>  let nextNode: listNode | undefined = listNode;
>  while (nextNode) {
>    // 删除第一个节点的next 防止死循环
>    if (currentNode && !previewNode) {
>      delete currentNode.next;
>    }
>    // 反转节点
>    if (currentNode && previewNode) {
>      currentNode.next = previewNode;
>    }
>
>    // 将三个指针向后瞬移
>    previewNode = currentNode;
>    currentNode = nextNode;
>    nextNode = nextNode.next;
>  }
>
>  // 处理 最后一个没有next的节点
>  currentNode!.next = previewNode;
>  return currentNode!;
>}
>
>```
>
>

##### 用链表实现一个队列

>* 单向链表，但要同时记录**head**和**tail**
>* **tail**入队，**head**出队
>* **length**要实时获取，不能遍历获取。
>
>```typescript
>interface listNode {
> value: number;
> next: listNode | null;
>}
>
>export class listNodeCreateQueue {
> private len = 0;
> // 初始化头
> private head: listNode | null = null;
> // 初始化尾部
> private tail: listNode | null = null;
> // 入队
> add(n: number) {
>   // 从尾部入队，所以next永远是null
>   const newListNode: listNode = {
>     value: n,
>     next: null,
>   };
>
>   if (this.head === null) {
>     // 将head 指向 newListNode
>     this.head = newListNode;
>   }
>
>   // 更新尾部节点
>   if (this.tail) {
>     // 这里的tail指向的还是上次的newListNode
>     this.tail.next = newListNode;
>   }
>
>   // 重新指向尾部节点
>   this.tail = newListNode;
>
>   this.len++;
> }
>
> // 出队
> delete(): number | null {
>   const headNode = this.head;
>   const value = headNode?.value;
>   if (!value) return null;
>   if (this.len <= 0) return null;
>
>   this.head = this.head!.next;
>   this.len--;
>   return value;
> }
>
> // 长度
> get length(): number {
>   return this.len;
> }
>}
>```
>
>#### 总结
>
>* 用数组实现队列和链表实现队列做对比
>
>* 数据结构的选择，要比算法优化更重要
>
>* 要有算法敏感度，比如length的查找

#### 5.二分查找法

##### 用js实现二分查找，并说明时间复杂度

>​	非常基础的算法，必会！
>
>#### 思路
>
>* 递归    -- 代码逻辑更清晰
>* 非递归   -- 性能更好
>* 时间复杂度O(logn)
>
>```typescript
>
>export function binarySearch(arr: number[], target: number): number {
>  const length = arr.length;
>  if (length == 0) return -1;
>  if (typeof target !== "number") return -1;
>  let startIndex = 0;
>  let endIndex = length - 1;
>  while (startIndex <= endIndex) {
>    let middleIndex = Math.floor((startIndex + endIndex) / 2);
>    if (arr[middleIndex] > target) {
>      endIndex = middleIndex - 1;
>    } else if (arr[middleIndex] < target) {
>      startIndex = middleIndex + 1;
>    } else {
>      return middleIndex;
>    }
>  }
>  return -1;
>}
>
>export function binarySearch2(
>  arr: number[],
>  target: number,
>  startIndex?: number,
>  endIndex?: number
>): number {
>  const length = arr.length;
>  if (length === 0) return -1;
>  if (typeof target !== "number") return -1;
>
>  if (startIndex == null) startIndex = 0;
>  if (endIndex == null) endIndex = length - 1;
>  let middleIndex = Math.floor((startIndex + endIndex) / 2);
>
>  if (startIndex > endIndex) return -1;
>
>  const value = arr[middleIndex];
>  if (value > target) {
>    return binarySearch2(arr, target, startIndex, middleIndex - 1);
>  } else if (value < target) {
>    return binarySearch2(arr, target, middleIndex + 1, endIndex);
>  } else {
>    return middleIndex;
>  }
>}
>```
>
>#### 总结
>
>* 凡有序，必二分
>
>* 凡二分，时间复杂度必包含**O(logn)**
>
>  

##### 查找一个递增的数组中两个数和为目标值的数

>#### 思路一
>
>* 最简单的一种，嵌套循环
>* 时间复杂度为 **O(n^2)**
>* 基本不可用 
>
>```typescript
>function tow_nums_add(arr: number[], target: number): number[] {
>  const length = arr.length;
>  const result: number[] = [];
>  if (length == 0) return result;
>  // 使用 flag 结束外面的循环
>  let flag = false;
>  for (let i = 0; i < arr.length; i++) {
>    const n = arr[i];
>    for (let j = i + 1; j < arr.length; j++) {
>      const k = arr[j];
>      if (n + k == target) {
>        result.push(i);
>        result.push(j);
>        flag = true;
>        break;
>      }
>    }
>    if (flag) break;
>  }
>  return result;
>}
>```
>
>#### 思路二
>
>* 双指针 **i**  指向 **arr[i]**  , **j**指向**arr[j]** 
>* 如果小于目标值，**i** 需要向后移动
>* 如果大于目标值，**j** 需要向前移动
>* 时间复杂度**O(n)**
>
>```typescript
>function tow_add_sum(arr: number[], target: number): number[] | [] {
>  const length = arr.length;
>  const result: number[] = [];
>  if (length == 0) return result;
>
>  let i = 0;
>  let j = length - 1;
>
>  while (i < j) {
>    const n = arr[i];
>    const k = arr[j];
>
>    if (n + k < target) {
>      i++;
>    } else if (n + k > target) {
>      j--;
>    } else {
>      result.push(i);
>      result.push(j);
>      break;
>    }
>  }
>
>  return result;
>}
>```
>
>#### 总结
>
>* 优化嵌套循环，优先考虑双指针。

#### 6. 二叉树（Binary Tree）

>* 是一棵树
>* 每个节点，最多只能有2个子节点
>* 数结构的数据 { value , left? , right? }
>

##### 二叉树的三种遍历方式

>* 前序遍历：root  =>  left   => right
>* 中序遍历：left   =>  root  => right
>* 后序遍历：left   =>  right => root 
>
>```typescript
>/**
>* @description 二叉树遍历
>*/
>
>interface IBinaryTree {
> value: number;
> left: IBinaryTree | null;
>  right: IBinaryTree | null;
> }
>
>const tree: IBinaryTree = {
>  value: 4,
>  left: {
>    value: 3,
>   left: {
>     value: 1,
>     left: null,
>      right: null,
>    },
>    right: {
>      value: 2,
>      left: null,
>      right: null,
>    },
>  },
>  right: {
>    value: 5,
>    left: {
>      value: 6,
>      left: null,
>      right: null,
>    },
>    right: {
>      value: 7,
>      left: null,
>      right: null,
>    },
>  },
> };
> 
> /**
> * @description 前序遍历
> */
> 
>function binaryTreeSearch1(tree: IBinaryTree | null) {
> if (tree == null) return;
> console.log(tree.value);
>  binaryTreeSearch1(tree.left);
>  binaryTreeSearch1(tree.right);
>}
>
> /**
> * @description 中序遍历
> */
> 
>function binaryTreeSearch2(tree: IBinaryTree | null) {
> if (tree == null) return;
> binaryTreeSearch2(tree.left);
>  console.log(tree.value);
>  binaryTreeSearch2(tree.right);
>}
>
> /**
> * @description 后序遍历
> */
> 
>function binaryTreeSearch3(tree: IBinaryTree | null) {
> if (tree == null) return;
> binaryTreeSearch3(tree.left);
>  binaryTreeSearch3(tree.right);
>  console.log(tree.value);
>}
>
> binaryTreeSearch3(tree);
> 
> ```
> 
>#### 总结
>
>- 就是递归的不同顺序

##### 二叉搜索树 bst (binary search tree)

>* left (包括其后代) value <= root value
>
>* right (包括其后代) value >= root value
>
>* 二叉搜索树的价值：可使用二分法快速查找
>
>  ![二叉搜索树](/Volumes/文件/网课资料/fe-interview-100-wiki/数据结构和算法/img/二叉搜索树.png)

##### 平衡二叉树（bbst）

> * 二叉树如果不平衡，就变成链表了

##### 红黑树

>* 自平衡二叉树
>* 分为 红/黑 两种颜色，通过颜色转换维持平衡
>* 相比平衡二叉搜索树，平衡效率更高
>
>![红黑树](/Volumes/文件/网课资料/fe-interview-100-wiki/数据结构和算法/img/红黑树.png)

##### B树

>* 物理上是多叉树，逻辑上是二叉树。
>
>* 一般用于高效 I/O，关系型数据库通常用B树来组织数据。
>
>  ![B树](/Volumes/文件/网课资料/fe-interview-100-wiki/数据结构和算法/img/B树.png)
